<!DOCTYPE html>
<html>

<head>
<!----------------------------------------------------------------------------->
<body onresize="ResizeCanvas()" onload="BodyLoad()">

<canvas id="mainCanvas"
        width="600"
        height="200"
        style="border:1px solid #c3c3c3;"
>
Your browser does not support the HTML5 canvas tag.
</canvas>

  <!------------------------------------------->
<table>
  <tr>
    <td align="center">
      <button onclick="ToggleStateVar( 'swreset' )">SwReset</button>
      <button onclick="ToggleStateVar( 'hwreset' )">HwReset</button>
      <button onclick="ToggleEnvelope( )">Envelope</button>
      <button onclick="TogglePeaks( )">Peaks</button>
  </tr>
    </td>
  </tr>
  <tr>
    <td>Connect</td>
    <td><div id="statusDiv"></div></td>
  </tr>
  <tr>
    <td>Device</td>
    <td><div id="timeDiv"></div></td>
  </tr>
  <tr>
    <td><button onclick="ToggleStateVar( 'run'     )">Run</button></td>
    <td><div id="runDiv"></div></td>
  </tr>
  <tr>
    <td><button onclick="ToggleStateVar( 'nAve'    )">N(ave)</button></td>
    <td><div id="nAveDiv"></div></td>
  </tr>
  <tr>
    <td><button onclick="ToggleStateVar( 'fftSize' )">FftSize</button></td>
    <td><div id="fftSizeDiv"></div></td>
  </tr>
  <tr>
    <td><button onclick="ToggleStateVar( 'ref' )">Ref(dB)</button></td>
    <td><div id="refDiv"></div></td>
  </tr>

</table>


</body>
<!----------------------------------------------------------------------------->
<script src="BJGT.js"></script>
<script>

var xyXvec = [];
var xyYvec = []
var xyPts  = 2048;
for(n=0;n<xyPts;n++){
   xyXvec[n] = n;
   xyYvec[n] = -30;
}

// This is the may xy plot
var bxy1 = new BJGT.XyDisplay( document.getElementById("mainCanvas") );
bxy1.SetTitle("Adc Display");
bxy1.SetXlabel("Freq(Hz)");
bxy1.SetYlabel("dBFS16");
bxy1.SetLogicalLimits( -100e3,100e3, -120,0 );
bxy1.Layout();
bxy1.EnableMouse();
bxy1.MarkersVisible( 1 );
bxy1.SetXy( xyXvec, xyYvec );

// Flag indicated state has recently been updated.
var stateUpdatedOk;

// Contents of state returned from device
var unitState;

// This method is to be invoked on initial loading
function BodyLoad()
{
   console.log( "BodyLoad: enter");
   ResizeCanvas();
}

// This method is to be invoked on a resize
function ResizeCanvas()
{
   var c1;

   console.log( "ResizeCanvas: enter");

   c1 =  document.getElementById("mainCanvas");
   c1.width  = window.innerWidth  * 0.95;
   c1.height = window.innerHeight * 0.60;
   bxy1.Layout();
   bxy1.Draw();
}

// This method is given a state variable name and inverts the ON/OFF value.
// The current value is taken from the most recently reported unit state
// The new value is set as a single name/value state property at the device
function ToggleStateVar( aVarStateName )
{
   var xmlhttp;
   xmlhttp=new XMLHttpRequest();

   var curValStr;
   var newValStr;

   curValStr= unitState[ aVarStateName ];
   console.log("current = " + curValStr);

   if( curValStr.toLowerCase() == "on" ){
      newValStr = "OFF";
   }
   else{
      newValStr = "ON";
   }

   console.log("new  = " + newValStr);

   xmlhttp.onreadystatechange=function() 
   {
      if (xmlhttp.readyState==4 && xmlhttp.status==200) 
      {
            ;
      }
   }
 
   // need to produce: setstate?v=name:value
   xmlhttp.open("GET",
                 "setstate?v=" + 
                 aVarStateName + 
                 ":" + 
                 newValStr,
                 true);
   xmlhttp.send();
}

// This method is given a state variable name and a div name.  The
// State variable is set at the device to the contents of the div name object
//
function SetStateVar( aVarStateName, aVarDivName )
{
   var xmlhttp;
   xmlhttp=new XMLHttpRequest();

   xmlhttp.onreadystatechange=function() 
   {
      if (xmlhttp.readyState==4 && xmlhttp.status==200) 
      {
            ;
      }
   }
 
   // need to produce: setstate?v={ name:value }
   xmlhttp.open("GET",
                 "setstate?v=" + 
                 aVarStateName + 
                 ":" + 
                 document.getElementsByName(aVarDivName)[0].value,
                 true);
   xmlhttp.send();
}

//
// This method updates the statusDiv specially.  If we have conducted
// a successful UpdateState() since this methods last invokation, the
// status div is updated as ok.  If this has not happened (i.e.
// a UpdateState() has failed to succeed and the connection to device
// is not valid) then marke the status as disconnected
//
function UpdateStatus()
{
    if( stateUpdatedOk!=0 ){
       document.getElementById("statusDiv").innerHTML=
                       "OK";
    }
    else{
       document.getElementById("statusDiv").innerHTML=
                       "<font color=red>DISCONNECTED</font>";
    }
    stateUpdatedOk = 0;
}

// This method issues a "getstate" GET request to the server, parses the
// return JSON data and populates all of the known divs using the device
// returned state.  If a good response has been received, parsed, and
// updated then the global variable stateUpdateOk is set to 1.
function UpdateState()
{
      var xmlhttp;
      xmlhttp=new XMLHttpRequest();

      xmlhttp.onreadystatechange=function() 
      {
         if (xmlhttp.readyState==4 && xmlhttp.status==200) 
         {
            // Display the raw input prior to parsing
            // console.log( xmlhttp.responseText ); 

            unitState = JSON.parse( xmlhttp.responseText );

            document.getElementById("runDiv").innerHTML    =unitState.run;
            document.getElementById("timeDiv").innerHTML   =unitState.time;
            document.getElementById("nAveDiv").innerHTML   =unitState.nAve;
            document.getElementById("fftSizeDiv").innerHTML=unitState.fftSize;
            document.getElementById("refDiv").innerHTML    =unitState.ref;

            stateUpdatedOk = 1;
         }
      }
      xmlhttp.open("GET","getstate",true);
      xmlhttp.send();
}

// This method must is to be invoked after the state is updated
// It pull any recently received xy points from the state and
// updates the display with them.
function UpdatePlot()
{
   // If the state has not been updated then nothing to do
   // if( 1!=stateUpdatedOk ) return;

   // console.log( "UpdatePlot: npc = " + unitState.npc );
   // console.log( "UpdatePlot: npi = " + unitState.npi );

   // FIXME - figure out 
   // xyVec.length = unitState.tpc;
   // xyVec.length = unitState.tpc;

   // Copy over any newly available display points
   for(sidx=0, didx=unitState.npi;sidx<unitState.npc;sidx++,didx++){
      xyXvec[didx] = unitState.npx[sidx];
      xyYvec[didx] = unitState.npy[sidx];
   }

   // Draw it
   // console.log( "[" + unitState.lim[0] +","+ unitState.lim[1]+"]" );
   // console.log( "[" + unitState.lim[2] +","+ unitState.lim[3]+"]" );
   bxy1.SetLogicalLimits( unitState.lim[0], unitState.lim[1], 
                          unitState.lim[2], unitState.lim[3] );
   bxy1.SetXy( xyXvec, xyYvec );
   bxy1.Draw();
}

////////////////////////////////////////////////////////////////////////////////
// This method is intended to be invoked periodically to update the display
// and to query the device for its state (so it can be displayed on the
// next invokation).
function PollDevice()
{
    // Update the status display based on current state
    UpdateStatus();

    // Issue a state update request to the device
    UpdateState();

    // Update the plot based on recent state data
    UpdatePlot();
}

// This sets the device polling rate.  The display is updated
// at this rate as well as the device being queried at this rate
setInterval(PollDevice,100);

var gPeaks = 0;
function TogglePeaks()
{
   if( gPeaks>0 ) gPeaks = 0;
   else           gPeaks = 9;

   bxy1.PeakPick( gPeaks );
}

function ToggleEnvelope()
{
   if( bxy1.EnvIsEnable() ){
      bxy1.EnvVisible( 0 );
      bxy1.EnvEnable(  0 );
      bxy1.Draw(); // force clear of env
   }
   else{
      bxy1.EnvEnable(  1 );
      bxy1.EnvVisible( 1 );
      // let the next draw show env
   }

}

</script>
</head>

</html>
